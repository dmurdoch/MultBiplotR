{
    "contents" : "\\name{GPA}\n\\alias{GPForth}\n\\alias{GPFoblq}\n\n\\title{Rotation Optimization}\n\\usage{\n    GPForth(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, maxit=1000, \n       method=\"varimax\", methodArgs=NULL)\n    GPFoblq(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, maxit=1000, \n       method=\"quartimin\", methodArgs=NULL)\n    }\n\\arguments{\n    \\item{A}{initial factor loadings matrix for which the rotation \n             criterian is to be optimized.}\n    \\item{Tmat}{initial rotation matrix.}\n    \\item{method}{rotation objective criterian.}\n    \\item{normalize}{see details.}\n    \\item{eps}{convergence is assumed when the norm of the gradient is smaller\n         than eps.}\n    \\item{maxit}{maximum number of iterations allowed in the main loop.}\n    \\item{methodArgs}{a list ofmethodArgs arguments passed to the rotation objective}\n}\n\n\\description{\n   Gradient projection rotation optimization routine used by various rotation\n   objective.\n   }\n\\value{A GPArotation object which is a list with elements \n  \\item{loadings}{The rotated loadings, one column for each factor.}\n  \\item{Th}{The rotation matrix,  Lh \\%*\\% t(Th) = A.}\n  \\item{Table}{A matrix recording the iterations of the rotation optimization.}\n  \\item{method}{A string indicating the rotation objective function.}\n  \\item{orthogonal}{A logical indicating if the rotation is orthogonal.}\n  \\item{convergence}{A logical indicating if convergence was obtained.}\n  \\item{Phi}{t(Th) \\%*\\% Th.  The covariance matrix of the rotated factors.\n  This will be the identity matrix for orthogonal\n  rotations so is omitted (NULL) for the result from GPForth.}\n  \\item{Gq}{The gradient of the objective function at the rotated loadings.}\n  }\n\\details{\n Gradient projection rotation optimization routines developed by\n Coen A. Bernaards and Robert I. Jennrich. These functions can be used directly\n to rotate a loadings matrix, or indirectly through a rotation\n objective passed to a factor estimation routine such as \\code{\\link{factanal}}.\n For examples of the indirect use see the documention for \n rotations (such as \\code{\\link{oblimin}}).\n\n \\code{GPForth} is the main GP algorithm for orthogonal rotation.\n \\code{GPFoblq} is the main GP algorithm for oblique rotation.\n Both algorithms require a loadings matrix \\code{A} which fixes the \n equivalence class over which the optimization is done. It must be \n the solution to the orthogonal factor analysis problem. \n A rotation is defined as \\code{A \\%*\\% t(solve(Tmat))}. For the \n orthogonal case \\code{Tmat} is orthonormal so this simplifies \n to \\code{A \\%*\\% Tmat}. The starting point for \n iterative optimization is given by the \\code{Tmat} rotation of \\code{A}. \n By default the initial rotation is the \n identity matrix. For some rotation criteria local optima may exist\n and it is recommended to check for this by starting with many different\n initial rotations. The function \\code{\\link{Random.Start}} will help to do\n this.\n \n The argument \\code{method} can be used to specify a string indicating\n the rotation objective. \\code{GPFoblq} defaults to \\code{\"quartimin\"} \n and \\code{GPForth} defaults to \\code{\"varimax\"}. Available rotation objectives\n are \\code{\"oblimin\"}, \\code{\"quartimin\"}, \\code{\"target\"}, \\code{\"pst\"},\n  \\code{\"oblimax\"}, \\code{\"entropy\"}, \n \\code{\"quartimax\"}, \\code{\"varimax\"}, \\code{\"simplimax\"}, \\code{\"bentler\"}, \n \\code{\"tandemI\"}, \\code{\"tandemII\"}, \n\\code{ \"geomin\"}, \\code{\"cf\"}, \\code{\"infomax\"} and \\code{\"mccammon\"}. \nThe string is prefixed with \n \"vgQ.\" to give the actual function call. The \\code{vgQ.*} function call\n would typically not be used directly, so these methods are not exported\n from the package namespace. You can print these functions to see the code for\n calculating a criterion, but since they are not exported the package \n name needs to be specified. For example, use\n \\code{GPArotation:::vgQ.oblimin} to view the function \\code{vgQ.oblimin}.\n\n Some rotation criteria (including \\code{\"simplimax\"}, \\code{\"pst\"}, \n \\code{\"procrustes\"})\n require one or more additional arguments. For example, \\code{\"simplimax\"}\n needs the number of 'close to zero loadings' which is given  as\n the extra argument \\code{k}. Check the rotation methods for details. \n (If a new rotation method is implemented and needs additional\n arguments then this is the  way to pass them.)\n\n The argument \\code{normalize} gives an indication of if and how any\n normalization should be done before rotation, and then undone after rotation.\n If \\code{normalize} is \\code{FALSE} (the default) no normalization is done.\n If \\code{normalize} is \\code{TRUE} then Kaiser normalization is done. (So\n squared row entries of normalized \\code{A} sum to 1.0. This is sometimes called\n Horst normalization.)\n If \\code{normalize} is a vector of length equal to the number of indicators (=\n number of rows of \\code{A}) then the colums are divided by \\code{normalize} \n before rotation and multiplied by \\code{normalize} after rotation. \n If \\code{normalize} is a function then it should take \\code{A} as an argument\n and return a vector which is used like the vector above. \n}\n\\seealso{\n   \\code{\\link{Random.Start}},\n   \\code{\\link[stats]{factanal}},\n   \\code{\\link{oblimin}},\n   \\code{\\link{quartimin}},\n   \\code{\\link{targetT}},\n   \\code{\\link{targetQ}},\n   \\code{\\link{pstT}},\n   \\code{\\link{pstQ}},\n   \\code{\\link{oblimax}},\n   \\code{\\link{entropy}},\n   \\code{\\link{quartimax}},\n   \\code{\\link{Varimax}},\n   \\code{\\link[stats]{varimax}},\n   \\code{\\link{simplimax}},\n   \\code{\\link{bentlerT}},\n   \\code{\\link{bentlerQ}},\n   \\code{\\link{tandemI}},\n   \\code{\\link{tandemII}},\n   \\code{\\link{geominT}},\n   \\code{\\link{geominQ}},\n   \\code{\\link{cfT}},\n   \\code{\\link{cfQ}},\n   \\code{\\link{infomaxT}},\n   \\code{\\link{infomaxQ}},\n   \\code{\\link{mccammon}},\n   \\code{\\link{promax}}\n}\n\\examples{\n  data(\"Harman\", package=\"GPArotation\")\n  qHarman  <- GPForth(Harman8, Tmat=diag(2), method=\"quartimax\")\n\n  data(\"WansbeekMeijer\", package=\"GPArotation\")\n  fa.unrotated  <- factanal(factors = 2, covmat=NetherlandsTV, \n              normalize=TRUE, rotation=\"none\")\n\n  GPForth(loadings(fa.unrotated), method=\"varimax\", normalize=TRUE)$loadings\n\n  TV <- GPFoblq(loadings(fa.unrotated), method=\"oblimin\", normalize=TRUE)\n\n  print(TV)\n  print(TV, Table=TRUE)\n  summary(TV)\n  }\n\\author{Coen A. Bernaards and Robert I. Jennrich\n        with some R modifications by Paul Gilbert}\n\\references{\n   Additional information is available at \n   \\url{http://www.stat.ucla.edu/research} or\n          \\url{http://www.stat.ucla.edu/research/gpa}\n   The software reference is\n\n   Bernaards, C.A. and Jennrich, R.I. (2005) Gradient Projection Algorithms \n     and Software for Arbitrary Rotation Criteria in Factor Analysis. \n     \\emph{Educational and Psychological Measurement}, \\bold{65}, 676--696.\n\n   Theory of gradient projection algorithms may be found in:\n\n   Jennrich, R.I. (2001). A simple general procedure for orthogonal rotation.\n       \\emph{Psychometrika}, \\bold{66}, 289--306.\n\n   Jennrich, R.I. (2002). A simple general method for oblique rotation. \n       \\emph{Psychometrika}, \\bold{67}, 7--19.\n   }\n\\concept{rotation}\n\\keyword{multivariate}\n",
    "created" : 1448976694322.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2642902349",
    "id" : "BDAA1D8C",
    "lastKnownWriteTime" : 1390270289,
    "path" : "~/Downloads/GPArotation 2/man/GPA.Rd",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_doc"
}