{
    "contents" : "# Los paquetes mirt, ltm, psych, lordif y foreign tienen que estar instalados antes de empezar\nlibrary(mirt)\nlibrary(foreign)\nlibrary(ltm)\nlibrary(psych)\nlibrary(lordif)\n\n\n\n# Antes de leer los datos no olvide cambiar el directorio de trabajo al que contiene el archivo\n# Todo funcionará mejor si sus columnas están todas definidas como numéricas\nDatos=read.spss(\"Linfomas.sav\", to.data.frame =TRUE)\nhead(Datos)\ndim(Datos)\n\n\n# Escalas: A - Molestias Somáticas B.- Ansiedad e insomnio C.- Disfuncion social D.- Depresion\n\nGHQ=Datos[,3:30]\nhead(GHQ)\n\n\n# ---------------------------------------------------------------------------------------------\n# Seleccionamos los datos que contienen los items de la escala A\n\nA=GHQ[,1:7]\nA=RemoveRowsWithNaNs(A)\nB=GHQ[,8:14] #Para la escala B\n# A=GHQ[,15:21] #Para la escala C\n# A=GHQ[,22:28] #Para la escala D\n\n\n# Analizamos la escala A\n# Calculamos, por ejemplo, la matriz de correlaciones tetracóricas (paquete psych)\nTetrA=tetrachoric(A)\nTetrA\n# Podemos factorizar la matriz de correlaciones tetracóricas\nirtA=irt.fa(TetrA)\nirtA\n# Mostramos la parte correspondiente al análisis factorial\nirtA$fa # Saturaciones y comunalidades\n# Mostramos información general\nsummary(irtA)\nprint(irtA)\n\n# Scree Plot\nplot(irtA$fa$values, main = \"Scree Plot\")\n# Puntos de corte de la correlación tetracórica\nirtA$tau\n# Parámetros en términos de discriminación y dificultad\nirtA$irt\n# Dibujos\ndev.new()\nop <- par(mfrow=c(3,1)) # Divide el gráfico en 3 para las representaciones siguientes\nplot(irtA,type=\"ICC\") # Curvas Caracteríaticas de los items\nplot(irtA,type=\"IIC\") # Curvas de información de los items\nplot(irtA,type=\"test\") # Curva de informacion del test\npar(op) # Devuelve el gráfico a su estado normal\n\n# Comparamos los resultados con los de otros paquetes : ltm\n# El modelo más sencillo es el modelo de Rasch que supone las discriminaciones iguales a 1\n# la restriccion se añade con constraint = cbind(ncol(A) + 1, 1) (ver la ayuda help(rasch))\nraschA=rasch(A, constraint = cbind(ncol(A) + 1, 1))\nraschA\nraschA$coefficients\ndev.new()\nop <- par(mfrow=c(2,1)) # Divide el gráfico en 2 para las representaciones siguientes\nplot(raschA,type=\"ICC\") # Curvas Caracteríaticas de los items\nplot(raschA,type=\"IIC\") # Curvas de información de los items\npar(op) # Devuelve el gráfico a su estado normal\n\n\n#Discriminaciones iguales, pero no necesariamente iguales a 1\nraschA2=rasch(A)\nraschA2\nraschA2$coefficients\n\ndev.new()\nop <- par(mfrow=c(2,1)) # Divide el gráfico en 2 para las representaciones siguientes\nplot(raschA2,type=\"ICC\") # Curvas Caracteríaticas de los items\nplot(raschA2,type=\"IIC\") # Curvas de información de los items\npar(op) # Devuelve el gráfico a su estado normal\n\n# Modelo de dos parámetros sin restricciones en la discriminacion\n# ltm :  Latent Trait Model - Latent Variable Model for Binary Data\n\n# z1 significa que tenemos un sólo factor\nltmA=ltm(A~z1)\nltmA\nltmA$coefficients\ncoef(ltmA, standardized=TRUE)\ndev.new()\nop <- par(mfrow=c(2,1)) # Divide el gráfico en 2 para las representaciones siguientes\nplot(ltmA,type=\"ICC\") # Curvas Caracteríaticas de los items\nplot(ltmA,type=\"IIC\") # Curvas de información de los items\npar(op) # Devuelve el gráfico a su estado normal\n\n# z1 + z2 significa que tenemos un sólo factor (ltm estima hasta dos factores)\nltmA2=ltm(A~z1+z2)\nltmA2\nltmA2$coefficients\ncoef(ltmA2, standardized=TRUE)\ndev.new()\nop <- par(mfrow=c(2,1)) # Divide el gráfico en 2 para las representaciones siguientes\nplot(ltmA,type=\"ICC\") # Curvas Caracteríaticas de los items\nplot(ltmA,type=\"IIC\") # Curvas de información de los items\npar(op) # Devuelve el gráfico a su estado normal\n\n\nsummary(raschA)\nsummary(raschA2)\nanova(raschA, raschA2)\nsummary(ltmA)\nsummary(ltmA2)\nanova(ltmA, ltmA2)\n\n# Puntuaciones factoriales de los individuos \nfsA=factor.scores.ltm(ltmA,resp.patterns=A, method=\"EAP\")$score.dat$z1\ndev.new()\nop <- par(mfrow=c(4,2))\nfor (i in 1:7)\nplot(fsA ~ as.factor(A[[i]]), , main=names(A[i]))\npar(op)\nfsA2=factor.scores.ltm(ltmA2,resp.patterns=A, method=\"EAP\")\nsc2=cbind(fsA2$score.dat$z1, fsA2$score.dat$z2)\nnp=round(sqrt(dim(A)[2]),digits=0)\ndev.new()\nop <- par(mfrow=c(np,np))\nfor (i in 1:(dim(A)[2]))\nplot(sc2[,1], sc2[,2], col=A[[i]]+1, asp=1, pch=16, xlab=\"F1\", ylab=\"F2\", main=names(A[i]))\npar(op)\n\n# Finalmente realizamos los ajustes con mirt\n\nmirtA=mirt(A, model=1) \nmirtA\nsummary(mirtA)\ncoef(mirtA)\ncoef(mirtA, IRTpars=TRUE)\ndev.new()\nplot(mirtA, type=\"info\")\ndev.new()\nplot(mirtA, type=\"trace\")\ndev.new()\nplot(mirtA, type=\"infotrace\")\ndev.new()\nitemplot(mirtA,1)\n\n\nmirtA2=mirt(A, model=2, rotate=\"varimax\") \nmirtA2\nsummary(mirtA2)\ncoef(mirtA2)\ndev.new()\nplot(mirtA2, type=\"info\")\n\nanova(mirtA, mirtA2)\nscm2=fscores(mirtA2, full.scores = TRUE, scores.only = TRUE)\ndev.new()\nop <- par(mfrow=c(np,np))\nfor (i in 1:(dim(A)[2]))\nplot(scm2[,1], scm2[,2], col=A[[i]]+1, asp=1, pch=16, xlab=\"F1\", ylab=\"F2\", main=names(A[i]))\npar(op)\n\n\nGHQmirt1=mirt(GHQ, model=1, rotate=\"varimax\") \nGHQmirt2=mirt(GHQ, model=2, rotate=\"varimax\") \nGHQmirt3=mirt(GHQ, model=3, rotate=\"varimax\") \nGHQmirt4=mirt(GHQ, model=4, rotate=\"varimax\") \n\nanova(GHQmirt1, GHQmirt2)\nanova(GHQmirt2, GHQmirt3)\nanova(GHQmirt3, GHQmirt4)\n\nsummary(GHQmirt4)\n\n\n\nDatos2=read.spss(\"BaseCuras.sav\", to.data.frame =T)\nhead(Datos2)\ndim(Datos2)\nTMMSd=Datos2[,10:33]\np=dim(TMMSd)[2]\nTMMS=NULL\nfor (i in 1:p)\nTMMS=cbind(TMMS, as.numeric(TMMSd[[i]]))\nA=TMMS[,1:8]\n# Polychoric Correlations\nPolyA=polychoric(A)\nPolyA\n# Podemos factorizar la matriz de correlaciones policóricas\nirtA=irt.fa(PolyA)\nirtA\n# Mostramos la parte correspondiente al análisis factorial\nirtA$fa # Saturaciones y comunalidades\n# Mostramos información general\nsummary(irtA)\nprint(irtA)\n\n# Scree Plot\nplot(irtA$fa$values, main = \"Scree Plot\")\n# Puntos de corte de la correlación tetracórica\nirtA$tau\n# Parámetros en términos de discriminación y dificultad\nirtA$irt\n# Dibujos\ndev.new()\nop <- par(mfrow=c(2,1)) # Divide el gráfico en 2 para las representaciones siguientes\nplot(irtA,type=\"IIC\") # Curvas de información de los items\nplot(irtA,type=\"test\") # Curva de informacion del test\npar(op) # Devuelve el gráfico a su estado normal\n\n# Finalmente realizamos los ajustes con mirt\n\nmirtA=mirt(A, model=1) \nmirtA\nsummary(mirtA)\ncoef(mirtA)\ncoef(mirtA, IRTpars=TRUE)\ndev.new()\nplot(mirtA, type=\"info\")\ndev.new()\nplot(mirtA, type=\"trace\")\ndev.new()\nplot(mirtA, type=\"infotrace\")\n\ndev.new()\nitemplot(mirtA,1)\n\n\nmirtA2=mirt(A, model=2, rotate=\"varimax\") \nmirtA2\nsummary(mirtA2)\ncoef(mirtA2)\ndev.new()\nplot(mirtA2, type=\"info\")\n\nanova(mirtA, mirtA2)\n\n\nscm2=fscores(mirtA2, full.scores = TRUE, scores.only = TRUE)\ndev.new()\nop <- par(mfrow=c(3,3))\nfor (i in 1:(dim(A)[2]))\nplot(scm2[,1], scm2[,2], col=A[,i], asp=1, pch=16, xlab=\"F1\", ylab=\"F2\", main=names(A[i]))\npar(op)\n\nTMMSmirt1=mirt(TMMS, model=1, rotate=\"varimax\") \nTMMSmirt2=mirt(TMMS, model=2, rotate=\"varimax\") \nTMMSmirt3=mirt(TMMS, model=3, rotate=\"varimax\") \n\n\nanova(TMMSmirt1, TMMSmirt2)\nanova(TMMSmirt2, TMMSmirt3)\n\n\nsummary(TMMSmirt3)\n\nbip1=OrdinalLogisticBiplot(TMMS, numFactors=3)\nsummary(bip1)\nplot(bip1,ColorInd=TMMS[,8], Clusters=as.factor(TMMS[,8]),   ColorVar=c(1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3), PlotClus=T, chulls=T, ColorCluster=c(1,2,3,4,5), ConfidentLevel=0.8)\ndev.new()\nplot(bip1, planex=1, planey=3,  ColorVar=c(1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3))\ndev.new()\nplot(bip1, planex=2, planey=3, ColorVar=c(1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3))\n\n\n\n",
    "created" : 1449661540757.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "542321051",
    "id" : "38DF978F",
    "lastKnownWriteTime" : 1439800247,
    "path" : "~/Library/Mobile Documents/com~apple~CloudDocs/Practica IRT R/GHQIRT.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}