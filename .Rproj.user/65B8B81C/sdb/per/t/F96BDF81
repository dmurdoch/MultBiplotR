{
    "collab_server" : "",
    "contents" : "BinaryLogBiplotEM <- function(x, freq=matrix(1,nrow(x),1), aini=NULL, dim = 2, nnodos = 15, tol = 1e-04, maxiter = 100, penalization = 0.2) {\n  # Nodos y ponderaciones de la cuadratura de Gauss-Hermite\n  Q = Multiquad(nnodos, dim)\n  X = Q$X\n  A = Q$A\n  q = dim(X)[1]\n  s = dim(x)[1]\n  \n  if (is.null(freq)) freq=matrix(1,s,1)\n  n = dim(x)[2]\n  # Parametros iniciales\n  print(\"Calculating initial parameters\")\n  par = matrix(0, n, dim + 1)\n  \n  xx=as.matrix(cbind(x, 1 - x))\n  # corr=CA(xx,dim=dim)\n  # ability=corr$RowCoordinates[,1:dim]\n  \n  if (is.null(aini)){\n    mod2 <- mirt(x,model=dim)\n    ability <- fscores(mod2,method = \"EAP\", full.scores = TRUE)}\n  else\n    ability=aini\n  \n  print(\"  \")\n  rownames(ability)=rownames(x)\n  colnames(ability)=paste(\"Axis\",1:dim)\n  \n  for (j in 1:n) par[j, ] = RidgeBinaryLogisticFit(x[, j], cbind(matrix(1, s, 1), ability), freq, tol, maxiter, penalization)\n  lin = cbind(matrix(1, s, 1), ability) %*% t(par)\n  PI = 1/(1 + exp(-1 * lin))\n  logLikold = sum(diagonal(freq) %*% log(PI^x * ((1 - PI)^(1 - x))))\n  \n  # Inicializacion de los parámetros de iteración\n  error = 1\n  iter = 0\n  \n  while ((error > tol) & (iter < maxiter)) {\n    # E-step\n    iter = iter + 1\n    abilityold=ability\n    parold=par\n    z = cbind(matrix(1, q, 1), X) %*% t(par)\n    plj = 1/(1 + exp(-1 * z))\n    plj=cbind(plj,1-plj)\n    L = matrix(1, s, q)\n    # for (l in 1:s) for (k in 1:q) for (j in 1:n) L[l, k] = L[l, k] * (plj[k, j]^x[l, j]) * ((1 - plj[k, j])^(1 - x[l, j]))\n    \n    for (l in 1:s) \n      for (k in 1:q)\n        L[l, k] = prod((plj[k,]^xx[l,]))\n    # ----- Hay que cambiar esta linea. Va muy lenta ....\n    \n    Pl = L %*% A\n    ability = matrix(0, s, dim)\n    for (l in 1:s) for (j in 1:dim) {\n      for (k in 1:q) ability[l, j] = ability[l, j] + X[k, j] * L[l, k] * A[k]\n      ability[l, j] = ability[l, j]/Pl[l]\n    }\n    # M-step  -  Calculo de los parametros\n    for (j in 1:n) par[j, ] = RidgeBinaryLogisticFit(x[, j], cbind(matrix(1, s, 1), ability), freq, tol, maxiter, penalization)\n    \n    lin = cbind(matrix(1, s, 1), ability) %*% t(par)\n    PI = 1/(1 + exp(-1 * lin))\n    logLik = sum(diagonal(freq) %*% log(PI^x * ((1 - PI)^(1 - x))))\n    error = (logLik - logLikold)/abs(logLik)\n    \n    if (error < 0){\n      ability=abilityold\n      par=parold}\n    else {\n      print(c(iter, logLik, error))}\n    logLikold = logLik\n  }\n  \n  p=n\n  Res=list()\n  Res$Biplot=\"Binary Logistic\"\n  Res$RowCoordinates=ability\n  Res$ColumnParameters=matrix(0,p,dimens+1)\n  Res$NullDeviances=matrix(0,p,1)\n  Res$ModelDeviances=matrix(0,p,1)\n  Res$Deviances=matrix(0,p,1)\n  Res$Dfs=matrix(0,p,1)\n  Res$pvalues=matrix(0,p,1)\n  Res$Bonferroni=matrix(0,p,1)\n  Res$Nagelkerke=matrix(0,p,1)\n  Res$R2=matrix(0,p,1)\n  Res$PercentsCorrec=matrix(0,p,1)\n  Res$DevianceTotal=0\n  Res$p=1\n  Res$TotalPercent=0\n  Res$SSRes=matrix(0,p,1)\n  Res$SSTot=matrix(0,p,1)\n  \n  for (i in 1:p){\n    cat(paste(\" \",i))\n    y=x[,i]\n    fit=RidgeBinaryLogistic(y,a,tolerance = tolerance, maxiter = maxiter, penalization=penalization, cte=TRUE)\n    Res$ColumnParameters[i,]=t(fit$beta)\n    Res$ModelDeviances[i]=fit$Deviance\n    Res$NullDeviances[i]=fit$NullDeviance\n    Res$Deviances[i]=fit$Dif\n    Res$Dfs[i]=fit$df\n    Res$pvalues[i]=fit$p\n    Res$Bonferroni[i]=(fit$p * p)* ((fit$p * p)<=1) + (((fit$p * p)>1))\n    Res$R2[i]=fit$R2\n    Res$CoxSnell[i]=fit$CoxSnell\n    Res$Nagelkerke[i]=fit$Nagelkerke\n    Res$MacFaden[i]=fit$MacFaden\n    Res$PercentsCorrec[i]=fit$PercentCorrect\n    Res$TotalPercent=Res$TotalPercent+sum(y==fit$Prediction)\n    Res$SSRes[i]=fit$SSRes\n    Res$SSTot[i]=fit$SSTot\n  }\n  \n  d = sqrt(rowSums(cbind(1,Res$ColumnParameters[, 2:(dimens + 1)])^2))\n  Res$Loadings = solve(diag(d)) %*% Res$ColumnParameters[, 2:(dimens + 1)]\n  Res$Tresholds = Res$ColumnParameters[, 1]/d\n  Res$Communalities = rowSums(Res$Loadings^2)\n  \n  rownames(Res$ColumnParameters)=colnames(x)\n  colnames(Res$ColumnParameters)=c(\"Const.\",paste(\"Dim\",1:dimens, sep=\"\"))\n  \n  rownames(Res$ColumnParameters)=colnames(x)\n  \n  Res$TotalPercent=Res$TotalPercent/(s*p)\n  Res$ModelDevianceTotal=sum(Res$ModelDeviances)\n  Res$NullDevianceTotal=sum(Res$NullDeviances)\n  Res$DevianceTotal=sum(Res$Deviances)\n  \n  Res$TotalSSRes=sum(Res$SSRes)\n  Res$TotalSSTot=sum(Res$SSTot)\n  \n  nn=length(x)\n  Res$TotCoxSnell=1-exp(-1*Res$DevianceTotal/nn)\n  Res$TotNagelkerke=Res$TotCoxSnell/(1-exp((Res$NullDevianceTotal/(-2)))^(2/nn))\n  Res$TotMacFaden=1-(Res$ModelDevianceTotal/Res$NullDevianceTotal)\n  Res$TotR2=1-(Res$TotalSSRes=sum(Res$SSRes)/Res$TotalSSTot)\n  Res$TotalDf=sum(Res$Dfs)\n  Res$p=1-pchisq(Res$DevianceTotal, df = Res$TotalDf)\n  Res$ClusterType=\"us\"\n  Res$Clusters = as.factor(matrix(1,nrow(Res$RowCoordinates), 1))\n  Res$ClusterColors=\"blue\"\n  Res$ClusterNames=\"ClusterTotal\"\n  class(Res) = \"Binary.Logistic.Biplot\"\n  \n  return(Res)\n  \n}\n",
    "created" : 1484248315539.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1438242968",
    "id" : "F96BDF81",
    "lastKnownWriteTime" : 1484834000,
    "last_content_update" : 1484834000,
    "path" : "~/Dropbox/0 ProgramasR/Paquetes/MultBiplotR/R/BinaryLogBiplotEM.R",
    "project_path" : "R/BinaryLogBiplotEM.R",
    "properties" : {
    },
    "relative_order" : 14,
    "source_on_save" : true,
    "source_window" : "",
    "type" : "r_source"
}